MODE FREQTABLE = STRUCT(
    INT x,
    INT f,
    REF FREQTABLE next
);

PROC ft_inc = (REF FREQTABLE ft, INT val) REF FREQTABLE:
# Returns the incremented row #
(
    REF FREQTABLE curr := ft;
    WHILE (next OF curr ISNT REF FREQTABLE(NIL)) ANDTH (x OF curr /= val) DO
        curr := next OF curr
    OD;
    IF x OF curr = val THEN
        f OF curr +:= 1;
        curr
    ELSE
        # allocate memory for a new freqtable row on the heap #
        next OF curr := HEAP FREQTABLE := (val, 1, NIL)
    FI
);

PROC ft_dropuntil = (REF FREQTABLE ft, INT val) INT:
# Removes rows prior to the one for which x >= val. #
# Returns that row's f if x = val, or 0 otherwise. #
# (Assumes the table is sorted!) #
(
    WHILE (next OF ft ISNT REF FREQTABLE(NIL)) ANDTH (x OF ft < val) DO
        # This modifies where ft points (even outside this scope)! #
        ft := next OF ft
    OD;
    IF x OF ft = val THEN
        f OF ft
    ELSE
        0
    FI
);

PROC shellsort = (REF []INT vals) VOID:
(
    [8]INT gaps := (701, 301, 132, 57, 23, 10, 4, 1);
    # Anything with 1 works; but Ciura's sequence is fastest known #
    FOR gap_index FROM LWB gaps TO UPB gaps DO
        INT gap := gaps[gap_index];
        FOR i FROM gap + 1 TO UPB vals DO
            INT tmp := vals[i];
            INT j := i;
            # The AND/OR operators do not automatically short-circuit! #
            # This screwed up my quicksort for the longest time >:( #
            # Use GNU extensions ANDTH/OREL instead. #
            WHILE j > gap ANDTH vals[j - gap] > tmp DO
                vals[j] := vals[j - gap];
                j -:= gap
            OD;
            vals[j] := tmp
        OD
    OD
);

PROC quicksort = (REF []INT vals, INT lower, upper) VOID:
(
    # sorts the list in place #
    IF lower < upper THEN
        INT pivot := vals[lower], left := lower + 1, right := upper;
        WHILE left <= right DO
            # leave elements that are already in the right place #
            WHILE left <= right ANDTH vals[left] <= pivot DO
                left +:= 1
            OD;
            WHILE left <= right ANDTH vals[right] >= pivot DO
                right -:= 1
            OD;
            # swap out-of-order elements into place #
            IF left < right THEN
                INT tmp := vals[left];
                vals[left] := vals[right];
                vals[right] := tmp
            FI
        OD;
        vals[lower] := vals[right];
        vals[right] := pivot;
        quicksort(vals, lower, right - 1);
        quicksort(vals, right + 1, upper)
    FI
);

FILE fp;
INT a, linecount := 1000;
[linecount]INT xs, ys;
open(fp, "input01.txt", stand in channel);
# TODO get lines until EOF detected #
FOR i TO linecount DO
    get(fp, a); xs[i] := a;
    get(fp, a); ys[i] := a
OD;
close(fp);

quicksort(xs, LWB xs, UPB xs);
quicksort(ys, LWB ys, UPB ys);
# Note that since y values are sorted,
  keeping track of the last-appended frequency table row
  ensures that inserting all y values takes only O(n).
  Additionally, by keeping both x values and the table sorted,
  looking up every table value takes only O(n) amortised
  (so long as we keep track of the last-read table row,
  or remove table rows when they're no longer required!)
#
FREQTABLE ys_ft := FREQTABLE(0, 0, NIL);
REF FREQTABLE current_row := ys_ft;
INT total := 0;
FOR i FROM LWB xs TO UPB xs DO
    total +:= ABS(xs[i] - ys[i]);
    current_row := ft_inc(current_row, ys[i])
OD;
print((total, newline));

total := 0;
FOR i FROM LWB xs TO UPB xs DO
    total +:= xs[i]*ft_dropuntil(ys_ft, xs[i])
OD;
print((total, newline))
