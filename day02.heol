(define cadr (lambda (xs) (car (cdr xs))))
(define bool->int (lambda (b) (if b 1 0)))
(define list (lambda args args))
(define sublist (lambda (n xs)
    (if (eq? 0 n) (cdr xs)
        (if (eq? 1 n)
            (cons (car xs) (cdr (cdr xs)))
            (sublist (- n 1) (cdr xs))))))

(define wrongup (lambda (i xs)
    (if (cdr xs)
        (if (or (< (cadr xs) (+ 1 (car xs)))
                (< (+ 3 (car xs)) (cadr xs)))
            (+ 1 i)
            (wrongup (+ 1 i) (cdr xs)))
        0)))
(define wrongdown (lambda (i xs)
    (if (cdr xs)
        (if (or (< (car xs) (+ 1 (cadr xs)))
                (< (+ 3 (cadr xs)) (car xs)))
            (+ 1 i)
            (wrongdown (+ 1 i) (cdr xs)))
        0)))
(define safe? (lambda (xs)
    (or (eq? 0 (wrongdown 0 xs))
        (eq? 0 (wrongup 0 xs)))))

(define safeish-up (lambda (xs)
    (let* (wrongi (wrongup 0 xs))
        (or (eq? 0 wrongi)
            (eq? 0 (wrongup 0 (sublist (- wrongi 1) xs)))
            (eq? 0 (wrongup 0 (sublist wrongi xs)))))))
(define safeish-down (lambda (xs)
    (let* (wrongi (wrongdown 0 xs))
        (or (eq? 0 wrongi)
            (eq? 0 (wrongdown 0 (sublist (- wrongi 1) xs)))
            (eq? 0 (wrongdown 0 (sublist wrongi xs)))))))
(define safeish? (lambda (xs)
    (or (safeish-up xs) (safeish-down xs))))

(define solve (lambda (xs)
    (print (list (bool->int (safe? xs)) (bool->int (safeish? xs)) '\n))))
